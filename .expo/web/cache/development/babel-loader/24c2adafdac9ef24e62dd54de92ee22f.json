{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.baseGestureHandlerWithMonitorProps = exports.baseGestureHandlerProps = void 0;\nexports.filterConfig = filterConfig;\nexports.findNodeHandle = findNodeHandle;\nexports.scheduleFlushOperations = scheduleFlushOperations;\n\nvar _reactNative = require(\"react-native\");\n\nvar _handlersRegistry = require(\"./handlersRegistry\");\n\nvar _utils = require(\"../utils\");\n\nvar _RNGestureHandlerModule = _interopRequireDefault(require(\"../RNGestureHandlerModule\"));\n\nvar commonProps = ['id', 'enabled', 'shouldCancelWhenOutside', 'hitSlop', 'cancelsTouchesInView'];\nvar componentInteractionProps = ['waitFor', 'simultaneousHandlers'];\nvar baseGestureHandlerProps = [].concat(commonProps, componentInteractionProps, ['onBegan', 'onFailed', 'onCancelled', 'onActivated', 'onEnded', 'onGestureEvent', 'onHandlerStateChange']);\nexports.baseGestureHandlerProps = baseGestureHandlerProps;\nvar baseGestureHandlerWithMonitorProps = [].concat(commonProps, ['needsPointerData', 'manualActivation']);\nexports.baseGestureHandlerWithMonitorProps = baseGestureHandlerWithMonitorProps;\n\nfunction isConfigParam(param, name) {\n  return param !== undefined && (param !== Object(param) || !('__isNative' in param)) && name !== 'onHandlerStateChange' && name !== 'onGestureEvent';\n}\n\nfunction filterConfig(props, validProps) {\n  var defaults = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var filteredConfig = Object.assign({}, defaults);\n\n  for (var key of validProps) {\n    var value = props[key];\n\n    if (isConfigParam(value, key)) {\n      if (key === 'simultaneousHandlers' || key === 'waitFor') {\n        value = transformIntoHandlerTags(props[key]);\n      } else if (key === 'hitSlop' && typeof value !== 'object') {\n        value = {\n          top: value,\n          left: value,\n          bottom: value,\n          right: value\n        };\n      }\n\n      filteredConfig[key] = value;\n    }\n  }\n\n  return filteredConfig;\n}\n\nfunction transformIntoHandlerTags(handlerIDs) {\n  handlerIDs = (0, _utils.toArray)(handlerIDs);\n\n  if (_reactNative.Platform.OS === 'web') {\n    return handlerIDs.map(function (_ref) {\n      var current = _ref.current;\n      return current;\n    }).filter(function (handle) {\n      return handle;\n    });\n  }\n\n  return handlerIDs.map(function (handlerID) {\n    var _handlerID$current;\n\n    return _handlersRegistry.handlerIDToTag[handlerID] || ((_handlerID$current = handlerID.current) === null || _handlerID$current === void 0 ? void 0 : _handlerID$current.handlerTag) || -1;\n  }).filter(function (handlerTag) {\n    return handlerTag > 0;\n  });\n}\n\nfunction findNodeHandle(node) {\n  if (_reactNative.Platform.OS === 'web') return node;\n  return (0, _reactNative.findNodeHandle)(node);\n}\n\nvar scheduledFlushOperationsId = null;\n\nfunction scheduleFlushOperations() {\n  if (scheduledFlushOperationsId === null) {\n    scheduledFlushOperationsId = requestAnimationFrame(function () {\n      _RNGestureHandlerModule.default.flushOperations();\n\n      scheduledFlushOperationsId = null;\n    });\n  }\n}","map":{"version":3,"mappings":"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","names":["commonProps","componentInteractionProps","baseGestureHandlerProps","baseGestureHandlerWithMonitorProps","isConfigParam","param","name","undefined","Object","filterConfig","props","validProps","defaults","filteredConfig","key","value","transformIntoHandlerTags","top","left","bottom","right","handlerIDs","toArray","Platform","OS","map","current","filter","handle","handlerID","handlerIDToTag","_handlerID$current","handlerTag","findNodeHandle","node","findNodeHandleRN","scheduledFlushOperationsId","scheduleFlushOperations","requestAnimationFrame","RNGestureHandlerModule","flushOperations"],"sources":["gestureHandlerCommon.ts"],"sourcesContent":["// Previous types exported gesture handlers as classes which creates an interface and variable, both named the same as class.\n// Without those types, we'd introduce breaking change, forcing users to prefix every handler type specification with typeof\n// e.g. React.createRef<TapGestureHandler> -> React.createRef<typeof TapGestureHandler>.\n// See https://www.typescriptlang.org/docs/handbook/classes.html#constructor-functions for reference.\nimport * as React from 'react';\nimport { Platform, findNodeHandle as findNodeHandleRN } from 'react-native';\n\nimport { State } from '../State';\nimport { TouchEventType } from '../TouchEventType';\nimport { ValueOf } from '../typeUtils';\nimport { handlerIDToTag } from './handlersRegistry';\nimport { toArray } from '../utils';\nimport RNGestureHandlerModule from '../RNGestureHandlerModule';\n\nconst commonProps = [\n  'id',\n  'enabled',\n  'shouldCancelWhenOutside',\n  'hitSlop',\n  'cancelsTouchesInView',\n] as const;\n\nconst componentInteractionProps = ['waitFor', 'simultaneousHandlers'] as const;\n\nexport const baseGestureHandlerProps = [\n  ...commonProps,\n  ...componentInteractionProps,\n  'onBegan',\n  'onFailed',\n  'onCancelled',\n  'onActivated',\n  'onEnded',\n  'onGestureEvent',\n  'onHandlerStateChange',\n] as const;\n\nexport const baseGestureHandlerWithMonitorProps = [\n  ...commonProps,\n  'needsPointerData',\n  'manualActivation',\n];\n\nexport interface GestureEventPayload {\n  handlerTag: number;\n  numberOfPointers: number;\n  state: ValueOf<typeof State>;\n}\nexport interface HandlerStateChangeEventPayload extends GestureEventPayload {\n  oldState: ValueOf<typeof State>;\n}\n\nexport type HitSlop =\n  | number\n  | Partial<\n      Record<\n        'left' | 'right' | 'top' | 'bottom' | 'vertical' | 'horizontal',\n        number\n      >\n    >\n  | Record<'width' | 'left', number>\n  | Record<'width' | 'right', number>\n  | Record<'height' | 'top', number>\n  | Record<'height' | 'bottom', number>;\n\n//TODO(TS) events in handlers\n\nexport interface GestureEvent<ExtraEventPayloadT = Record<string, unknown>> {\n  nativeEvent: Readonly<GestureEventPayload & ExtraEventPayloadT>;\n}\nexport interface HandlerStateChangeEvent<\n  ExtraEventPayloadT = Record<string, unknown>\n> {\n  nativeEvent: Readonly<HandlerStateChangeEventPayload & ExtraEventPayloadT>;\n}\n\nexport type TouchData = {\n  id: number;\n  x: number;\n  y: number;\n  absoluteX: number;\n  absoluteY: number;\n};\n\nexport type GestureTouchEvent = {\n  handlerTag: number;\n  numberOfTouches: number;\n  state: ValueOf<typeof State>;\n  eventType: TouchEventType;\n  allTouches: TouchData[];\n  changedTouches: TouchData[];\n};\n\nexport type GestureUpdateEvent<\n  GestureEventPayloadT = Record<string, unknown>\n> = GestureEventPayload & GestureEventPayloadT;\n\nexport type GestureStateChangeEvent<\n  GestureStateChangeEventPayloadT = Record<string, unknown>\n> = HandlerStateChangeEventPayload & GestureStateChangeEventPayloadT;\n\nexport type CommonGestureConfig = {\n  enabled?: boolean;\n  shouldCancelWhenOutside?: boolean;\n  hitSlop?: HitSlop;\n};\n\n// Events payloads are types instead of interfaces due to TS limitation.\n// See https://github.com/microsoft/TypeScript/issues/15300 for more info.\nexport type BaseGestureHandlerProps<\n  ExtraEventPayloadT extends Record<string, unknown> = Record<string, unknown>\n> = CommonGestureConfig & {\n  id?: string;\n  waitFor?: React.Ref<unknown> | React.Ref<unknown>[];\n  simultaneousHandlers?: React.Ref<unknown> | React.Ref<unknown>[];\n  testID?: string;\n  cancelsTouchesInView?: boolean;\n  // TODO(TS) - fix event types\n  onBegan?: (event: HandlerStateChangeEvent) => void;\n  onFailed?: (event: HandlerStateChangeEvent) => void;\n  onCancelled?: (event: HandlerStateChangeEvent) => void;\n  onActivated?: (event: HandlerStateChangeEvent) => void;\n  onEnded?: (event: HandlerStateChangeEvent) => void;\n\n  //TODO(TS) consider using NativeSyntheticEvent\n  onGestureEvent?: (event: GestureEvent<ExtraEventPayloadT>) => void;\n  onHandlerStateChange?: (\n    event: HandlerStateChangeEvent<ExtraEventPayloadT>\n  ) => void;\n  // implicit `children` prop has been removed in @types/react^18.0.0\n  children?: React.ReactNode;\n};\n\nfunction isConfigParam(param: unknown, name: string) {\n  // param !== Object(param) returns false if `param` is a function\n  // or an object and returns true if `param` is null\n  return (\n    param !== undefined &&\n    (param !== Object(param) ||\n      !('__isNative' in (param as Record<string, unknown>))) &&\n    name !== 'onHandlerStateChange' &&\n    name !== 'onGestureEvent'\n  );\n}\n\nexport function filterConfig(\n  props: Record<string, unknown>,\n  validProps: string[],\n  defaults: Record<string, unknown> = {}\n) {\n  const filteredConfig = { ...defaults };\n  for (const key of validProps) {\n    let value = props[key];\n    if (isConfigParam(value, key)) {\n      if (key === 'simultaneousHandlers' || key === 'waitFor') {\n        value = transformIntoHandlerTags(props[key]);\n      } else if (key === 'hitSlop' && typeof value !== 'object') {\n        value = { top: value, left: value, bottom: value, right: value };\n      }\n      filteredConfig[key] = value;\n    }\n  }\n  return filteredConfig;\n}\n\nfunction transformIntoHandlerTags(handlerIDs: any) {\n  handlerIDs = toArray(handlerIDs);\n\n  if (Platform.OS === 'web') {\n    return handlerIDs\n      .map(({ current }: { current: any }) => current)\n      .filter((handle: any) => handle);\n  }\n  // converts handler string IDs into their numeric tags\n  return handlerIDs\n    .map(\n      (handlerID: any) =>\n        handlerIDToTag[handlerID] || handlerID.current?.handlerTag || -1\n    )\n    .filter((handlerTag: number) => handlerTag > 0);\n}\n\nexport function findNodeHandle(\n  node: null | number | React.Component<any, any> | React.ComponentClass<any>\n): null | number | React.Component<any, any> | React.ComponentClass<any> {\n  if (Platform.OS === 'web') return node;\n  return findNodeHandleRN(node);\n}\n\nlet scheduledFlushOperationsId: ReturnType<\n  typeof requestAnimationFrame\n> | null = null;\n\nexport function scheduleFlushOperations() {\n  if (scheduledFlushOperationsId === null) {\n    scheduledFlushOperationsId = requestAnimationFrame(() => {\n      RNGestureHandlerModule.flushOperations();\n\n      scheduledFlushOperationsId = null;\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"script"}